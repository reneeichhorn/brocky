#include "quic_server.h"

void QUICServer::cleanup() {
  WSACleanup();

  if (pConfig) {
    quiche_config_free(pConfig);
    pConfig = nullptr;
  }
}

static void debug_log(const char *line, void *argp) {
  //fprintf(stderr, "[QUICHE DEBUG] %s\n", line);
}

bool QUICServer::initialize() {
  // Initialize winsock
	if (WSAStartup(MAKEWORD(2,2), &pWSA) != 0) {
		printf("Could not load winsock2.2 (error code: %d)\n", WSAGetLastError());
    return false;
	}
  
  // Initialize server socket. 
  if((pServerSocket = socket(AF_INET , SOCK_DGRAM , 0 )) == INVALID_SOCKET) {
		printf("Could not create server socket (error code: %d)\n", WSAGetLastError());
    return false;
	}

  // Prepare socket setup.
  struct sockaddr_in serverAddr;
  serverAddr.sin_family = AF_INET;
	serverAddr.sin_addr.s_addr = INADDR_ANY;
	serverAddr.sin_port = htons(1337);

  // Bind to address.
	if(bind(pServerSocket ,(struct sockaddr *)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
		printf("Failed to bind to port 1337 (error code: %d)\n", WSAGetLastError());
    return false;
	}

  // Set socket to non-blocking
  u_long mode = 1;
  if (ioctlsocket(pServerSocket, FIONBIO, &mode) != NO_ERROR) {
		printf("Failed to set socket to non-blocking (error code: %d)\n", WSAGetLastError());
    return false;
  }

  // Initialize quiche config
  quiche_enable_debug_logging(debug_log, NULL);
  pConfig = quiche_config_new(QUICHE_PROTOCOL_VERSION);
  if (!pConfig) {
    printf("Failed to create quiche configuration\n");
    return false;
  }

  // Apply configuration.
  quiche_config_load_cert_chain_from_pem_file(pConfig, "certs/cert.crt");
  quiche_config_load_priv_key_from_pem_file(pConfig, "certs/cert.key");
  quiche_config_set_application_protos(pConfig,
    (uint8_t *) "\x05hq-27\x05hq-25\x05hq-24\x05hq-23\x08http/0.9", 21);
  quiche_config_set_max_packet_size(pConfig, MAX_DATAGRAM_SIZE);
  quiche_config_enable_early_data(pConfig);
  quiche_config_verify_peer(pConfig, false);
  quiche_config_set_max_packet_size(pConfig, MAX_DATAGRAM_SIZE);
  quiche_config_set_initial_max_data(pConfig, 0x0FFFFFFFFFFFFFFF);
  quiche_config_set_initial_max_stream_data_bidi_local(pConfig, 0x0FFFFFFFFFFFFFFF);
  quiche_config_set_initial_max_stream_data_bidi_remote(pConfig, 0x0FFFFFFFFFFFFFFF);
  quiche_config_set_initial_max_streams_bidi(pConfig, 0x0FFFFFFFFFFFFFFF);
  quiche_config_set_cc_algorithm(pConfig, QUICHE_CC_RENO);

  return true;
}

std::string hexStr(char *data, int len) {
  std::stringstream ss;
  ss << std::hex;

  for( int i(0) ; i < len; ++i )
      ss << std::setw(2) << std::setfill('0') << (int)data[i];

  return ss.str();
}

/// Generate a stateless retry token.
///
/// The token includes the static string `"quiche"` followed by the IP address
/// of the client and by the original destination connection ID generated by the
/// client.
///
/// Note that this function is only an example and doesn't do any cryptographic
/// authenticate of the token. *It should not be used in production system*.
static void mint_token(const uint8_t *dcid, size_t dcid_len,
                       struct sockaddr_in *addr, int addr_len,
                       uint8_t *token, size_t *token_len) {
  memcpy(token, "quiche", sizeof("quiche") - 1);
  memcpy(token + sizeof("quiche") - 1, addr, addr_len);
  memcpy(token + sizeof("quiche") - 1 + addr_len, dcid, dcid_len);
  *token_len = sizeof("quiche") - 1 + addr_len + dcid_len;
}

static bool validate_mint_token(const uint8_t *token, size_t token_len,
                           struct sockaddr_in *addr, int addr_len,
                           uint8_t *odcid, size_t *odcid_len) {
    if ((token_len < sizeof("quiche") - 1) ||
         memcmp(token, "quiche", sizeof("quiche") - 1)) {
        return false;
    }

    token += sizeof("quiche") - 1;
    token_len -= sizeof("quiche") - 1;

    if ((token_len < addr_len) || memcmp(token, addr, addr_len)) {
        return false;
    }

    token += addr_len;
    token_len -= addr_len;

    if (*odcid_len < token_len) {
        return false;
    }

    memcpy(odcid, token, token_len);
    *odcid_len = token_len;

    return true;
}

void QUICServer::tick(std::vector<std::vector<uint8_t>>* frameData) {
  // Send frame data to all active connections.
  for (auto iter = clientRefs.begin(); iter != clientRefs.end(); iter++) {
    // Only take clients that are ready.
    auto ref = iter->second.quiche_ref;
    auto isEstablished = quiche_conn_is_established(ref);
    auto isEarlyStage = quiche_conn_is_in_early_data(ref);
    auto isClosed = quiche_conn_is_closed(ref);
    if (isEstablished || isEarlyStage) {
      uint64_t id = 0;

      // Check for readable packets. 
      quiche_stream_iter *readable = quiche_conn_readable(ref);

      while (quiche_stream_iter_next(readable, &id)) {
        bool finish = false;
        size_t recv_len = quiche_conn_stream_recv(ref, id, (uint8_t*)pBuffer, sizeof(pBuffer), &finish);
        //printf("[QUIC] Got reable stream (size: %zd, fin: %s)\n", recv_len, finish ? "true" : "false");
      }
      quiche_stream_iter_free(readable);

      // Force quiche to create sliced QUIC packets.
      quiche_stream_iter *writeable = quiche_conn_writable(ref);

      while (quiche_stream_iter_next(writeable, &id)) {
        bool finish = false;
        size_t amount = 0;
        for (auto chunkIter = frameData->begin(); chunkIter != frameData->end(); chunkIter++) {
          size_t recv_len = quiche_conn_stream_send(ref, id, chunkIter->data(), chunkIter->size(), false);
          amount += chunkIter->size();
          //printf("[QUIC] Creating QUIC packet for frame data (size: %zd)\n", recv_len);
        }
        printf("[QUIC] Sent %zd frame chunks with a total of %zd bytes to client %d\n", frameData->size(), amount, id);
      }
      quiche_stream_iter_free(writeable);
    }

    // Get all outstanding QUIC packets and send them over.
    while (true) {
      size_t written = quiche_conn_send(ref, pSendBuffer, sizeof(pSendBuffer));
      if (written == QUICHE_ERR_DONE) {
        break;
      }

      // Send retry packet over udp.
      size_t sent = sendto(pServerSocket, (char*)pSendBuffer, written, 0,
                           &iter->second.addr,
                            sizeof(iter->second.addr));
      
      //printf("[QUIC] Sending QUIC packet over UDP (size: %d; actual: %d)\n", written, sent);
    }
  }

  // Try to read raw udp data
  int recvLength = 0;
  struct sockaddr_in peer_addr;
  int peer_addr_len = sizeof(peer_addr);
  memset(&peer_addr, 0, peer_addr_len);

  if ((recvLength = recvfrom(pServerSocket, pBuffer, BUFFER_LEN, 0, (struct sockaddr *)&peer_addr, &peer_addr_len)) == SOCKET_ERROR) {
    auto error = WSAGetLastError();

    // Since we do not want to block we simply ignore this tick in case that there is no data.
    if (error == WSAEWOULDBLOCK) {
      return;
    }

		printf("[UDP] Failed to read from socket (error code: %d)\n", WSAGetLastError());
  }

  //printf("[Socket] UDP message received (length: %d)\n", recvLength);

  // Get header from quic raw data.
  uint8_t type;
  uint32_t version;

  uint8_t scid[QUICHE_MAX_CONN_ID_LEN];
  size_t scid_len = sizeof(scid);

  uint8_t dcid[QUICHE_MAX_CONN_ID_LEN];
  size_t dcid_len = sizeof(dcid);

  uint8_t odcid[QUICHE_MAX_CONN_ID_LEN];
  size_t odcid_len = sizeof(odcid);

  uint8_t token[MAX_TOKEN_LEN];
  size_t token_len = sizeof(token);

  int rc = quiche_header_info((uint8_t*)pBuffer, recvLength, LOCAL_CONN_ID_LEN, &version,
                              &type, scid, &scid_len, dcid, &dcid_len,
                              token, &token_len);

  // Check if client is already registered
  auto clientKey = hexStr((char*)dcid, dcid_len);
  auto client = clientRefs.find(clientKey);

  // Client has not sent a token yet -> therefore assume its a new client.
  if (client == clientRefs.end() && token_len == 0) {
    this->negotiateVersion(version);
    this->createToken(scid, scid_len, dcid, dcid_len, &peer_addr, peer_addr_len, token, &token_len);
    printf("[QUIC] Retry packet with new token generated (token: %s)\n", hexStr((char *)token, token_len).c_str());
    printf("[QUIC] ODCID when retry was sent: %s\n", hexStr((char *)odcid, odcid_len).c_str());
    return;
  }

  // Create new client if not yet happened.
  if (client == clientRefs.end()) {
    // Validate token.
    if (!validate_mint_token(token, token_len, &peer_addr, peer_addr_len, odcid, &odcid_len)) {
      printf("[QUIC] Client sent invalid token ??? whyyyy\n");
      return;
    }
    printf("[QUIC] ODCID after validating: %s\n", hexStr((char *)odcid, odcid_len).c_str());
    printf("[QUIC] ODCID when accepting: %s\n", hexStr((char *)odcid, odcid_len).c_str());
    printf("[QUIC] Token when accepting: %s\n", hexStr((char *)token, token_len).c_str());
    auto ref = quiche_accept(dcid, dcid_len, odcid, odcid_len, pConfig);

    ClientRef newClient;
    newClient.quiche_ref = ref;
    memcpy(newClient.dcid, dcid, dcid_len);
    memcpy(&newClient.addr, (void*)&peer_addr, peer_addr_len);

    clientRefs.insert(std::pair<std::string, ClientRef>(clientKey, newClient));
    client = clientRefs.find(clientKey);

    printf("[QUIC] New client registered. (token: %s)\n", hexStr((char*)token, token_len).c_str());
  }

  // Send over all messages to quiche to handle quiche implementation.
  size_t done = quiche_conn_recv(client->second.quiche_ref, (uint8_t*)pBuffer, recvLength);
}


void QUICServer::createToken(
  const uint8_t *scid, size_t scid_len,
  const uint8_t *dcid, size_t dcid_len,
  struct sockaddr_in *addr, int addr_len,
  uint8_t *token, size_t *token_len
) {
  // Create a new token based on address and connection id.
  mint_token(dcid, dcid_len, addr, addr_len, token, token_len);

  // Create quiche retry packet with new token.
  size_t written = quiche_retry(scid, scid_len,
                                  dcid, dcid_len,
                                  dcid, dcid_len,
                                  token, *token_len,
                                  pSendBuffer, sizeof(pSendBuffer));

  // Send retry packet over udp.
  size_t sent = sendto(pServerSocket, (char*)pSendBuffer, written, 0,
                        (struct sockaddr *)addr,
                        addr_len);

  printf("[QUIC] Send retry package (size: %d, actual: %d)\n", written, sent);
}

void QUICServer::negotiateVersion(uint32_t version) {
  // TODO
}

  